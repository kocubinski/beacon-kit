package sszdb

import (
	"math"
	"strconv"

	"github.com/berachain/beacon-kit/mod/consensus-types/pkg/types"
)

// this file contains functions to parse object paths into a gindex.
// it would be generated by tool which ingests plain old go structs and spits out the gindex calculation

type schemaNode struct {
	gindex   uint64
	order    uint64
	height   uint64
	length   uint64
	list     bool
	children lookupTable
}

func (s *schemaNode) isByteVector() bool {
	return s.length > 32 && s.height == 0
}

type lookupTable map[string]*schemaNode
type objectPath []string

func getSchemaNode(path objectPath) *schemaNode {
	// todo: pass in root for partial traversal from subtree
	prev := beaconStateLookup["."]
	var (
		node *schemaNode
		ok   bool
	)
	for _, p := range path {
		switch {
		case prev.list:
			if p == "__len__" { // "__len__" reserved
				node = &schemaNode{
					gindex: 2*prev.gindex + 1,
					length: 8,
				}
				break
			}
			// TODO this incorrectly asssumes all list elements are 32 bytes, that is, either container types
			// or basic types 32 bytes in length.
			i, err := strconv.ParseUint(p, 10, 64)
			if err == nil {
				node = &schemaNode{
					gindex:   powerTwo(prev.height-1)*prev.gindex + i,
					length:   prev.length,   // list specifies the element length
					children: prev.children, // children specifies the element schema
					height:   ceilLog2(uint64(len(prev.children))) + 1,
				}
				break
			}

		default:
			node, ok = prev.children[p]
			if !ok {
				return nil
			}
			node.gindex = powerTwo(prev.height-1)*prev.gindex + node.order
			if node.isByteVector() {
				numLeaves := math.Ceil(float64(node.length) / 32)
				depth := ceilLog2(uint64(numLeaves))
				node.gindex = powerTwo(depth) * node.gindex
			}
		}
		prev = node
	}
	return node
}

var beaconStateLookup = map[string]*schemaNode{
	".": {
		gindex: 1, // root node gindex=1
		height: 5,
		children: lookupTable{
			"genesis_validators_root": {
				length: 32,
				order:  0,
			},
			"slot": {
				length: 8,
				order:  1,
			},
			"fork": {
				height: 3,
				order:  2,
				children: lookupTable{
					"previous_version": {
						order:  0,
						length: 4,
					},
					"current_version": {
						order:  1,
						length: 4,
					},
					"epoch": {
						order:  2,
						length: 8,
					},
				},
			},
			"latest_block_header": {
				height: 4,
				order:  3,
				children: lookupTable{
					"slot": {
						order:  0,
						length: 8,
					},
					"proposer_index": {
						order:  1,
						length: 8,
					},
					"parent_block_root": {
						order:  2,
						length: 32,
					},
					"state_root": {
						order:  3,
						length: 32,
					},
					"body_root": {
						order:  4,
						length: 32,
					},
				},
			},
			"block_roots": {
				// calc height for perfect binary tree with 8192 leaves, +1 for length node
				height: ceilLog2(nextPowerOfTwo(8192)) + 2,
				order:  4,
				list:   true,
				length: 32,
			},
			"validators": {
				height: ceilLog2(nextPowerOfTwo(1099511627776)) + 2,
				order:  9,
				list:   true,
				length: uint64((&types.Validator{}).SizeSSZ()),
				children: lookupTable{
					"pubkey": {
						order:  0,
						length: 48,
					},
					"withdrawal_credentials": {
						order:  1,
						length: 32,
					},
					"effective_balance": {
						order:  2,
						length: 8,
					},
					"slashed": {
						order:  3,
						length: 1,
					},
					"activation_eligibility_epoch": {
						order:  4,
						length: 8,
					},
					"activation_epoch": {
						order:  5,
						length: 8,
					},
					"exit_epoch": {
						order:  6,
						length: 8,
					},
					"withdrawable_epoch": {
						order:  7,
						length: 8,
					},
				},
			},
		},
	},
}
