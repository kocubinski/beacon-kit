package sszdb

import "strconv"

// this file contains functions to parse object paths into a gindex.
// it would be generated by tool which ingests plain old go structs and spits out the gindex calculation

type schemaNode struct {
	gindex   uint64
	order    uint64
	height   uint64
	length   uint64
	list     bool
	children lookupTable
}

type lookupTable map[string]*schemaNode
type objectPath []string

func getSchemaNode(path objectPath) *schemaNode {
	prev := beaconStateLookup["."]
	var (
		node *schemaNode
		ok   bool
	)
	for _, p := range path {
		switch {
		case prev.list:
			if p == "__len__" { // "__len__" reserved
				node = &schemaNode{
					gindex: 2*prev.gindex + 1,
					length: 8,
				}
				break
			}
			i, err := strconv.ParseUint(p, 10, 64)
			if err == nil {
				node = &schemaNode{
					gindex: powerTwo(prev.height-1)*prev.gindex + i,
					length: prev.length, // list specifies the element length
				}
				break
			}
			fallthrough

		default:
			node, ok = prev.children[p]
			if !ok {
				return nil
			}
			node.gindex = powerTwo(prev.height-1)*prev.gindex + node.order
		}
		prev = node
	}
	return node
}

var beaconStateLookup = map[string]*schemaNode{
	".": {
		gindex: 1,
		height: 5,
		children: lookupTable{
			"genesis_validators_root": {
				length: 32,
				order:  0,
			},
			"slot": {
				length: 8,
				order:  1,
			},
			"fork": {
				height: 3,
				order:  2,
				children: lookupTable{
					"previous_version": {
						order:  0,
						length: 4,
					},
					"current_version": {
						order:  1,
						length: 4,
					},
					"epoch": {
						order:  2,
						length: 8,
					},
				},
			},
			"latest_block_header": {
				height: 4,
				order:  3,
				children: lookupTable{
					"slot": {
						order:  0,
						length: 8,
					},
					"proposer_index": {
						order:  1,
						length: 8,
					},
					"parent_block_root": {
						order:  2,
						length: 32,
					},
					"state_root": {
						order:  3,
						length: 32,
					},
					"body_root": {
						order:  4,
						length: 32,
					},
				},
			},
			"block_roots": {
				// calc height for perfect binary tree with 8192 leaves, +1 for length node
				height: ceilLog2(nextPowerOfTwo(8192*2)) + 1,
				order:  4,
				list:   true,
				length: 32,
			},
		},
	},
}
